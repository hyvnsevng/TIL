# 자료구조
- 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것

**데이터구조 활용**
- 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용하기

## 메서드
- 클래스(타입을 표현하는 방법) 내부에 정의되는 함수
- 데이터 타입별로 사용 가능
- `데이터 타입 객체.메서드()`와 같은 형태로 호출

### 문자열 메서드
|문자열 조회/탐색 메서드|설명|
|--------|:----:|
|**`s.find(x)`**|x의 첫번째 위치 반환, 없으면 -1 반환|
|**`s.index(x)`**|x의 첫번째 위치 반환, 없으면 error|
|**`s.isupper()`**|문자열이 모두 대문자인지 확인|
|**`s.islower()`**|문자열이 모두 소문자인지 확인|
|**`s.isalpha()`**|문자열이 알파벳(한국어 포함)으로만 이루어져있는지 확인|

|문자열 조작 메서드 | 설명 |
| --- | :---: | 
|**`s.replace(old, new[, count])`**|바꿀 대상 글자를 새로운 글자로 바꿔서 반환|
|**`s.strip([chars])`**|문자열의 시작과 끝에 있는 공백이나 특정 문자 제거|
|**`s.split(sep=None, maxsplit=-1)`**|공백이나 특정 문자 기준으로 분리|
|**`'seperator'.join(iterable)`** |맨 앞글자는 대문자, 나머지는 소문자로 변경|
|`s.capitalize()`| 문자열 내 띄어쓰기 기준으로 |
|`s.title()`| 공백 기준 대문자 처리 |
|`s.upper()`| 전부 대문자로 |
|`s.lower()`| 전부 소문자로 |
|`s.swapcase()`| 대문자는 소문자로, 소문자는 대문자로 |

- 위 메서드들은 원본 문자열을 수정하지 않고 새 문자열 반환 (str : immutable)
    - `문자열 조작 메서드는 반드시 변수에 결과를 할당하자`
- 메서드는 이어서 사용가능
    ```py
    text = 'heLLo, woRld!'
    new_text = text.swapcase().replace('l', 'z')
    print(new_text)     
    ```
    - type이 맞아야 오류 발생하지 않고 연결 가능

### 리스트 메서드
| 리스트 값 추가 및 삭제 메서드 | 설명 |
| ------ | :--:|
| **`L.append(x)`** | 리스트 마지막에 x 추가 |
| **`L.extend(iterable)`** | 리스트에 다른 반복 가능한 객체의 모든 항목 추가 |
| **`L.insert(i, x)`** | i번째 인덱스에 x 삽입 |
| **`L.remove(x)`** | 가장 첫번째 x 제거 |
| **`L.pop()`** | 가장 마지막 인덱스 반환 후 제거 |
| **`L.pop(i)`** | i번째 항목 반환 후 제거 |
| `L.clear()` | 모든 항목 삭제 |
- append와 extend 차이
    ```py
    # append
    my_list = [1, 2, 3]
    my_list.append([4, 5, 6])
    print(my_list)          # [1, 2, 3, [4, 5, 6]]

    # extend
    my_list = [1, 2, 3]
    my_list.extend([4, 5, 6]) 
    print(my_list)          # [1, 2, 3, 4, 5, 6]
    ```
| 리스트 탐색 및 정렬 메서드 | 설명 |
| -------------| :--------------: |
|` L.index(x) `| 첫번째 x의 인덱스 반환 |
| `L.count(x)` | 리스트 내 x의 개수 반환 |
| **`L.reverse()`** | 리스트 순서를 역순으로 변경 |
| **`L.sort()`** | 원본 리스트를 오름차순으로 정렬 |
|**` L.sort(reverse=True) `**| 원본 리스트를 내림차순으로 정렬 |

- 문자열 메서드와 달리 대부분의 리스트 메서드(index, count 제외)는 반환이 없음
    - 문자열 메서드는 원본 문자열을 바꾸지 않고 바꾼 문자열을 반환
    - 리스트 메서드는 원본 자체를 수정하고 반환값이 없음
        ```py
        my_list = [1, 2, 3]

        print(my_list.append(4))        # None
        ```

## 복사 ( 중요 ! )

- 파이썬에서는 데이터 분류(mutable/immutable)에 따라 복사가 달라짐
```py
a = [0]
result = []
for i in range(1, 4):
    a[0] = i
    result.append(a)        #[[3], [3], [3]]
```

- a를 어디서 선언하냐에 따라 결과가 달라질 수 있다.
```py
a = {}
result = []
for i in range(1, 4):
    a[f'a{i}'] = i          
    result.append(a)        # [{'a1': 1, 'a2': 2, 'a3': 3},
                            # {'a1': 1, 'a2': 2, 'a3': 3}, 
print(result)               # {'a1': 1, 'a2': 2, 'a3': 3}]     
```
```py
result = []
for i in range(1, 4):
    a = {}
    a[f'a{i}'] = i
    result.append(a)

print(result)   # [{'a1': 1}, {'a2': 2}, {'a3': 3}]
```
### 할당
```py
a = [1, 2, 3, 4]
b = a
b[0] = 100
print(a)            # [100, 2, 3, 4]

a = 20
b = a
b = 10
print(a, b)         # 20 10
```

- list : 가변 데이터 --> b에 a를 할당 (동일 객체)
- int : 불변 데이터 --> b에 새로운 값 재할당

### 얕은 복사
```py
a = [1, 2, 3]
b = a[:]
b[0] = 100

print(a)        # [1, 2, 3]
print(b)        # [100, 2, 3]

c = a.copy()
c[0] = 999

print(a)        # [1, 2, 3]
print(c)        # [999, 2, 3]
```
- L.copy()는 리스트의 모든 항목을 슬라이싱한 것을 할당한 것과 같은 동작

    #### 얕은 복사의 한계
    ```py
    a = [1, 2, [3, 4, 5]]
    b = a[:]

    b[0] = 999
    print(a)            # [1, 2, [3, 4, 5]]
    print(b)            # [999, 2, [3, 4, 5]]

    b[2][1] = 100
    print(a)            # [1, 2, [3, 100, 5]]
    print(b)            # [999, 2, [3, 100, 5]]
    ```
    - a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경됨
    - mutable type에서 발생(dict, list, set)
### 깊은 복사
```py
import copy


a = [1, 2, [3, 4, 5]]
b = copy.deepcopy(a)

b[2][1] = 100
print(a)            # [1, 2, [3, 4, 5]]
```
- copy 모듈 사용



**참고**

- **`isdecimal()`** : 0~9 사이의 숫자 판별
- `isdigit()` : 유니코드 숫자 판별
- `isnumeric()` : 분수, 지수, 루트

위 메서드들은 소수/음수는 판별 불가('.', '-' 등의 문자열을 숫자로 인식 X)